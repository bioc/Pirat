---
title: "Pirat"
author: "Lucas Etourneau, Samuel Wieczorek"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Pirat}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Table of content

1. [Pirat installation](#dunno)

### Pirat installation

### Prerequest

The functions in Pirat use some Python libraries. Before installing Pirat, it is necessary to have Python 3.9.5 installed on the computer.
This version can be found here:
https://www.python.org/downloads/release/python-395/


### Installation

To install this package from Github:

```{r, eval=F}
library(remotes)
remotes::install_github('prostarproteomics/Pirat')

```

Once the package has been installed, it is necessary to install a Python environment (called r-pirat in the package) with specific versions of Python libraries. For this purpose, run: 

```{r, eval=F}
Pirat::install_pirat()

```
If Python is not found by R during environment installation, you can either execute
```{r, eval=F}
reticulate::use_python("path_to_python_binary")
```
Or, if you are using RStudio, set your RStudio Python interpreter to the one installed on your machine (in your RStudio window, go in "Global Options" -> "Python" -> "python interpreter"). Then, retry to install the Python environment r-pirat.


This will install all necessary Python modules and restart the R session. Infos about versions can be obtained with:
```{r, eval=F}
pirat_config()
```


## Standard imputation with Pirat

Load Pirat package and a reduced part of Bouyssie2020 dataset in the environment.
```{r, eval=F}
library(Pirat)
data("bouyssie")
```

Note that `bouyssie` is actually a list that contains two elements:

1. `peptides_ab`, the matrix of peptide log-2-abundances, with samples in rows and peptides in columns.
2. `adj`, the adjacency matrix between peptides and proteins, containing etiher booleans or 0s and 1s.

You can then impute this dataset with the following line
```{r, eval=F}
imp.res <- pipeline_llkimpute(bouyssie)
```

The result `imp.res` is a list that contains:

1. `data.imputed`, the imputed log-2 abundance matrix.
2. `params`, a list containing parameters $\Gamma$ and hyperparameters $\alpha$ and $\beta$.

You can check the imputed values here...
```{r}
head(imp.res$data.imputed[1:5])
```

...and the computed parameters here.
```{r}
imp.res$params
```
Note that a positive value for $\gamma_1$ indicates that a random left-truncation mechanism
is present in the dataset.

## Intra-PG correlation analysis

Pirat has a diagnosis tool that compares distributions of correlations at random and those from same peptide groups (PGs).
We use it here on the complete Ropers2021 dataset.
```{r}
data("ropers")
plot_pep_correlations(ropers, titlename = "Ropers2021")
```
 We see here that the blue distribution has much more weights on high correlations than the red one,
 indicating that making PGs should clearly help for imputation.
 
 ## Pirat extensions
 
 To handle singleton PGs, Pirat proposes three extentions, on top of the classical Pirat approach.
 Note that the -T extensions can be applied to up to an arbitrary PG size.
 To illustrate our examples, we use a subset of Ropers2021 dataset.
 
 ### -2, the 2-peptide rule
 
 The -2 extension simply consists in not imputing singleton PGs. It can be used as following.
```{r}
data("subropers")
imp.res = pipeline_llkimpute(subropers, extension = "2")
```
We can then check that singleton peptides are not imputed (yet some may be already fully observed).
```{r}
idx.sing.pg = which(colSums(subropers$adj) == 1)
idx.sing.pep = which(rowSums(subropers$adj[, idx.sing.pg]) >= 1)
imp.res$data.imputed[, idx.sing.pep]
```

### -S, samples-wise correlations

Pirat can leverage sample-wise correlations to impute the singleton peptides as following:
```{r}
imp.res = pipeline_llkimpute(subropers, extension = "S")
```
Here singleton peptides are impute after the rest of the dataset, using sample-wise correlations obtained.
```{r}
idx.sing.pg = which(colSums(subropers$adj) == 1)
idx.sing.pep = which(rowSums(subropers$adj[, idx.sing.pg]) >= 1)
imp.res$data.imputed[, idx.sing.pep]
```

### -T, transcriptomic integration

The last extension consists in using correlations between peptides and gene/transcript expression obtained from a related transcriptomic analysis. To use this extension, the list of the dataset must contain:

* `rnas_ab`, an log2-normalized-count table of gene or transcript expression, for which samples are either paired or related (*i.e.*, from the same experimental/biological conditions).
* `adj_rna_pg`, a adjacency matrix between transcripts or genes and PGs, containing either booleans or 0s and 1s.

`ropers` proteomic and transcriptomic samples are paired (*i.e.* the same biological samples were used for each type of analysis). Thus Pirat-T can be used as following:
```{r}
imp.res = pipeline_llkimpute(subropers,
                             extension = "T",
                             rna.cond.mask = 1:nrow(ropers$peptides_ab),
                             pep.cond.mask = 1:nrow(ropers$peptides_ab),
                             max.pg.size.pirat.t = +Inf)
```

And gives following imputed singletons:
```{r}
idx.sing.pg = which(colSums(ropers$adj) == 1)
idx.sing.pep = which(rowSums(ropers$adj[, idx.sing.pg]) >= 1)
imp.res$data.imputed[, idx.sing.pep]
```
On the other hand, if proteomic and transcriptomic samples are not paired but are derived from a same biological/experimental condition. Pirat-T can be use by adapting the mask related to samples in each type of analysis (here, both proteomic and transcriptomic samples 6 different conditions with 3 replicates each, and conditions appear in the same order):
```{r}
imp.res = pipeline_llkimpute(ropers,
                             extension = "T",
                             rna.cond.mask = rep(1:6, each = 3),
                             pep.cond.mask = rep(1:6, each = 3))
```
Also, it is possible to apply transcriptomic integration up to an arbitrary size of PG, simply by 
changing parameter `max.pg.size.pirat.t` in `pipeline_llkimpute` to the desired PG size (*e.g.* `+Inf` if one wants to use for whole dataset).
