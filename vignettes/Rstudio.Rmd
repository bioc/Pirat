---
title: "Pirat"
author: "Lucas Etourneau, Samuel Wieczorek"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Pirat}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography:
  - biblio_vignette.bib
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Table of content

1. [Pirat installation](#pi)
2. [Standard imputation with Pirat](#siwp)
3. [Intra-PG correlation analysis](#ipgca)
4. [Pirat extensions](#pe)
5. [References](#refs)

### 1. Pirat installation <a name="pi"></a>

### Prerequest

The functions in Pirat use some Python libraries. Before installing Pirat, it is necessary to have Python 3.9.5 installed on the computer.
This version can be found here:
https://www.python.org/downloads/release/python-395/


### Installation

To install this package from Github:

```{r, eval=F}
library(remotes)
remotes::install_github('prostarproteomics/Pirat')
```

Once the package has been installed, it is necessary to install a Python environment (called r-pirat in the package) with specific versions of Python libraries. For this purpose, run: 

```{r, eval=F}
Pirat::install_pirat()
```

<!-- If Python is not found by R during environment installation, you can either execute -->
<!-- ```{r, eval=F} -->
<!-- reticulate::use_python("path_to_python_binary") -->
<!-- ``` -->
<!-- Or, if you are using RStudio, set your RStudio Python interpreter to the one installed on your machine (in your RStudio window, go in "Global Options" -> "Python" -> "python interpreter"). Then, retry to install the Python environment r-pirat. -->


This will install all necessary Python modules and restart the R session. Infos about versions can be obtained with:
```{r, eval=F}
Pirat::pirat_config()
```


## 2. Standard imputation with Pirat <a name="siwp"></a>

Load Pirat package and a subset of Bouyssie2020 dataset in the environment.
```{r}
library(Pirat)
data("subbouyssie")
```

Note that `subbouyssie` is actually a list that contains two elements:

1. `peptides_ab`, the matrix of peptide log-2-abundances, with samples in rows and peptides in columns.
2. `adj`, the adjacency matrix between peptides and proteins, containing etiher booleans or 0s and 1s.

You can then impute this dataset with the following line
```{r}
imp.res <- pipeline_llkimpute(subbouyssie)
```

The first plot represents the goodness of fit of the inverse-gamma prior, whereas the second one
represents the goodness of fit of the missingness mechanism (details on fitting methods are given in @Etourneau2023). Note that some of these parameters were originally proposed in @Chen2014, however no methods existed to find then automatically and without relying on heuristics.

The result `imp.res` is a list that contains:

1. `data.imputed`, the imputed log-2 abundance matrix.
2. `params`, a list containing parameters $\Gamma$ and hyperparameters $\alpha$ and $\beta$.

You can check the imputed values here...
```{r test1}
head(imp.res$data.imputed[1:5])
```

...and the computed parameters here.
```{r}
imp.res$params
```
Note that a positive value for $\gamma_1$ indicates that a random left-truncation mechanism
is present in the dataset.

## 3. Intra-PG correlation analysis <a name="ipgca"></a>

Pirat has a diagnosis tool that compares distributions of correlations at random and those from same peptide groups (PGs).
We use it here on the complete Ropers2021 dataset.
```{r}
data("ropers")
plot_pep_correlations(ropers, titlename = "Ropers2021")
```
 We see here that the blue distribution has much more weights on high correlations than the red one,
 indicating that making PGs should clearly help for imputation.
 
## 4. Pirat extensions <a name="pe"></a>
 
To handle singleton PGs, Pirat proposes three extentions, on top of the classical Pirat approach.
Note that the -T extensions can be applied to up to an arbitrary PG size.
To illustrate our examples, we use a subset of Ropers2021 dataset.
 
### -2, the 2-peptide rule
 
The -2 extension simply consists in not imputing singleton PGs. It can be used as following.
```{r}
data("subropers")
imp.res = pipeline_llkimpute(subropers, extension = "2")
```

We can then check that singleton peptides are not imputed (yet some may be already fully observed).
```{r}
idx.sing.pg = which(colSums(subropers$adj) == 1)
idx.sing.pep = which(rowSums(subropers$adj[, idx.sing.pg]) >= 1)
imp.res$data.imputed[, idx.sing.pep]
```

### -S, samples-wise correlations

Pirat can leverage sample-wise correlations to impute the singleton peptides as following:
```{r}
imp.res = pipeline_llkimpute(subropers, extension = "S")
```

Here singleton peptides are impute after the rest of the dataset, using sample-wise correlations obtained.
```{r}
idx.sing.pg = which(colSums(subropers$adj) == 1)
idx.sing.pep = which(rowSums(subropers$adj[, idx.sing.pg]) >= 1)
imp.res$data.imputed[, idx.sing.pep]
```

### -T, transcriptomic integration

The last extension consists in using correlations between peptides and gene/transcript expression obtained from a related transcriptomic analysis. To use this extension, the list of the dataset must contain:

* `rnas_ab`, an log2-normalized-count table of gene or transcript expression, for which samples are either paired or related (*i.e.*, from the same experimental/biological conditions).
* `adj_rna_pg`, a adjacency matrix between transcripts or genes and PGs, containing either booleans or 0s and 1s.

`ropers` proteomic and transcriptomic samples are paired (*i.e.* the same biological samples were used for each type of analysis). Thus Pirat-T can be used as following:
```{r}
imp.res = pipeline_llkimpute(subropers,
                             extension = "T",
                             rna.cond.mask = 1:nrow(ropers$peptides_ab),
                             pep.cond.mask = 1:nrow(ropers$peptides_ab),
                             max.pg.size.pirat.t = 1)
```

Only few peptides have been used to fit the prior variance distribution in  , as we use a small subset from the original Ropers2021 dataset. Thus the goodness of fit may vary a lot depending on the subset chosen.

And gives following imputed singletons:
```{r}
idx.sing.pg = which(colSums(subropers$adj) == 1)
idx.sing.pep = which(rowSums(subropers$adj[, idx.sing.pg]) >= 1)
imp.res$data.imputed[, idx.sing.pep]
```

On the other hand, if proteomic and transcriptomic samples are not paired but are derived from a same biological/experimental condition. Pirat-T can be use by adapting the mask related to samples in each type of analysis (here, both proteomic and transcriptomic samples 6 different conditions with 3 replicates each, and conditions appear in the same order):
```{r}
imp.res = pipeline_llkimpute(subropers,
                             extension = "T",
                             rna.cond.mask = rep(1:6, each = 3),
                             pep.cond.mask = rep(1:6, each = 3),
                             max.pg.size.pirat.t = 1)
```

Also, it is possible to apply transcriptomic integration up to an arbitrary size of PG, simply by 
changing parameter `max.pg.size.pirat.t` in `pipeline_llkimpute` to the desired limit PG size (*e.g.* `+Inf` for whole dataset).

## 5. References (#refs)
